<?php // Poscast - restorelib.php, 24/02/2007/** * Fonction de sauvegarde de l'activité Podcast.  */		    function podcast_restore_mods($mod,$restore) {        global $CFG;        $status = true;        //Get record from backup_ids        $data = backup_getid($restore->backup_unique_code,$mod->modtype,$mod->id);        if ($data) {            //Now get completed xmlized object               $info = $data->info;            // Now, build the podcast record structure            $podcast->course = $restore->course_id;			$podcast->userid = backup_todb($info['MOD']['USERID']['0']['#']);            $podcast->name = backup_todb($info['MOD']['#']['NAME']['0']['#']);            $podcast->author = backup_todb($info['MOD']['#']['AUTHOR']['0']['#']);            $podcast->intro = backup_todb($info['MOD']['#']['INTRO']['0']['#']);            $podcast->owner = backup_todb($info['MOD']['#']['OWNER']['0']['#']);            $podcast->owner_email = backup_todb($info['MOD']['#']['OWNER_EMAIL']['0']['#']);            $podcast->copyright = backup_todb($info['MOD']['#']['COPYRIGHT']['0']['#']);            $podcast->lang = backup_todb($info['MOD']['#']['LANG']['0']['#']);            $podcast->pubdate = backup_todb($info['MOD']['#']['PUBDATE']['0']['#']);            $podcast->image_url = backup_todb($info['MOD']['#']['IMAGE_URL']['0']['#']);            $podcast->image_img = backup_todb($info['MOD']['#']['IMAGE_IMG']['0']['#']);            $podcast->category = backup_todb($info['MOD']['#']['CATEGORY']['0']['#']);            $podcast->timemodified = backup_todb($info['MOD']['#']['TIMEMODIFIED']['0']['#']);			            //The structure is equal to the db, so insert the podcast            $newid = insert_record ("podcast",$podcast);									//We have to recode the userid field            $user = backup_getid($restore->backup_unique_code,"user",$item->userid);            if ($user) {                $podcast->userid = $user->new_id;            }            //Do some output                 if (!defined('RESTORE_SILENTLY')) {                echo "<li>".get_string("modulename","podcast")." \"".format_string(stripslashes($podcast->name),true)."\"</li>";            }            backup_flush(300);            if ($newid) {                //We have the newid, update backup_ids                backup_putid($restore->backup_unique_code,$mod->modtype,                             $mod->id, $newid);                //Now check if want to restore user data and do it.                if (restore_userdata_selected($restore,'podcast',$mod->id)) {                    //Restore podcast_items                    $status = podcast_items_restore_mods ($mod->id, $newid,$info,$restore);                }            } else {                $status = false;            }        } else {            $status = false;        }        return $status;    }    //This function restores the podcast_items    function podcast_items_restore_mods($old_podcast_id, $new_podcast_id, $info, $restore) {        global $CFG;        $status = true;        //Get the items array         $items = $info['MOD']['#']['ITEMS']['0']['#']['ITEM'];        //Iterate over items        for($i = 0; $i < sizeof($items); $i++) {            $items_info = $items[$i];            //We'll need this later!!            $oldid = backup_todb($items_info['#']['ID']['0']['#']);            //Now, build the podcast_itemS record structure            $item->id_podcast = $new_podcast_id;            $item->title = backup_todb($items_info['#']['TITLE']['0']['#']);            $item->lien = backup_todb($items_info['#']['LIEN']['0']['#']);            $item->intro = backup_todb($items_info['#']['INTRO']['0']['#']);            $item->pubdate = backup_todb($items_info['#']['PUBDATE']['0']['#']);            $item->date_html = backup_todb($items_info['#']['DATE_HTML']['0']['#']);			$item->duration = backup_todb($items_info['#']['DURATION']['0']['#']);			$item->length = backup_todb($items_info['#']['LENGTH']['0']['#']);            //The structure is equal to the db, so insert the podcast_item            $newid = insert_record ("podcast_structure",$item);									//Now copy moddata associated files            if ($newid) {				// Check folder permissions				if (! is_writable($CFG->dirroot."/mod/podcast/media/") && !defined('RESTORE_SILENTLY')) {					echo "<li style='color:red;font-size:0.9em;font-weight:bold;'>";					echo get_string('chmod_media_1','podcast')."<br />";					echo get_string('chmod_media_2','podcast');					echo "</li>";					$status = false;				} 				if (! is_writable($CFG->dirroot."/mod/podcast/publication/") && !defined('RESTORE_SILENTLY')) {					echo "<li style='color:red;font-size:0.9em;font-weight:bold;'>";					echo get_string('chmod_publication_1','podcast')."<br />";					echo get_string('chmod_publication_2','podcast');					echo "</li>";					$status = false;				}				if ($status)					$status = podcast_restore_files ($old_podcast_id, $new_podcast_id, $oldid, $newid, $restore);			}			backup_flush(300);						//Do some output            if (($i+1) % 50 == 0) {                if (!defined('RESTORE_SILENTLY')) {                    echo ".";                    if (($i+1) % 1000 == 0) {                        echo "<br />";                    }                }                backup_flush(300);            }        }        return $status;    }    //Return a content decoded to support interactivities linking. Every module    //should have its own. They are called automatically from    //podcast_decode_content_links_caller() function in each module    //in the restore process    function podcast_decode_content_links ($content,$restore) {                    global $CFG;                    $result = $content;                        //Link to the list of podcasts                        $searchstring='/\$@(PODCASTINDEX)\*([0-9]+)@\$/';        //We look for it        preg_match_all($searchstring,$content,$foundset);        //If found, then we are going to look for its new id (in backup tables)        if ($foundset[0]) {            //print_object($foundset);                                     //Debug            //Iterate over foundset[2]. They are the old_ids            foreach($foundset[2] as $old_id) {                //We get the needed variables here (course id)                $rec = backup_getid($restore->backup_unique_code,"course",$old_id);                //Personalize the searchstring                $searchstring='/\$@(PODCASTINDEX)\*('.$old_id.')@\$/';                //If it is a link to this course, update the link to its new location                if($rec->new_id) {                    //Now replace it                    $result= preg_replace($searchstring,$CFG->wwwroot.'/mod/podcast/index.php?id='.$rec->new_id,$result);                } else {                     //It's a foreign link so leave it as original                    $result= preg_replace($searchstring,$restore->original_wwwroot.'/mod/podcast/index.php?id='.$old_id,$result);                }            }        }        //Link to podcast view by moduleid        $searchstring='/\$@(PODCASTVIEWBYID)\*([0-9]+)@\$/';        //We look for it        preg_match_all($searchstring,$result,$foundset);        //If found, then we are going to look for its new id (in backup tables)        if ($foundset[0]) {            //print_object($foundset);                                     //Debug            //Iterate over foundset[2]. They are the old_ids            foreach($foundset[2] as $old_id) {                //We get the needed variables here (course_modules id)                $rec = backup_getid($restore->backup_unique_code,"course_modules",$old_id);                //Personalize the searchstring                $searchstring='/\$@(podcastVIEWBYID)\*('.$old_id.')@\$/';                //If it is a link to this course, update the link to its new location                if($rec->new_id) {                    //Now replace it                    $result= preg_replace($searchstring,$CFG->wwwroot.'/mod/podcast/view.php?id='.$rec->new_id,$result);                } else {                    //It's a foreign link so leave it as original                    $result= preg_replace($searchstring,$restore->original_wwwroot.'/mod/podcast/view.php?id='.$old_id,$result);                }            }        }        return $result;    }    //This function makes all the necessary calls to xxxx_decode_content_links()    //function in each module, passing them the desired contents to be decoded    //from backup format to destination site/course in order to mantain inter-activities    //working in the backup/restore process. It's called from restore_decode_content_links()    //function in restore process    function podcast_decode_content_links_caller($restore) {        global $CFG;        $status = true;                if ($podcasts = get_records_sql ("SELECT m.id, m.intro                                   FROM {$CFG->prefix}podcast m                                   WHERE m.course = $restore->course_id")) {                                               //Iterate over each podcast->intro            $i = 0;   //Counter to send some output to the browser to avoid timeouts            foreach ($podcasts as $podcast) {                //Increment counter                $i++;                $content = $podcast->intro;                $result = restore_decode_content_links_worker($content,$restore);                if ($result != $content) {                    //Update record                    $podcast->intro = addslashes($result);                    $status = update_record("podcast",$podcast);                    if (debugging()) {                        if (!defined('RESTORE_SILENTLY')) {                            echo '<br /><hr />'.s($content).'<br />changed to<br />'.s($result).'<hr /><br />';                        }                    }                }                //Do some output                if (($i+1) % 5 == 0) {                    if (!defined('RESTORE_SILENTLY')) {                        echo ".";                        if (($i+1) % 100 == 0) {                            echo "<br />";                        }                    }                    backup_flush(300);                }            }        }        return $status;    }    //This function copies the podcast related info from backup temp dir to course moddata folder,    //creating it if needed and recoding everything (podcast id and post id)    function podcast_restore_files ($oldid_podcast, $newid_podcast, $oldid, $newid, $restore) {        global $CFG;        $status = true;        $todo = false;        $moddata_path = "";        $podcast_path = "";        $temp_path = "";	    // MEDIA    	// in CFG->dataroot        $dest_dir = $CFG->dirroot."/mod/podcast/media/".$restore->course_id;        $status = check_dir_exists($dest_dir,true);		        //Now, locate podcast directory        if ($status) {            $podcast_path = $dest_dir."/".$newid_podcast;            //Check it exists and create it            $status = check_dir_exists($podcast_path,true);        }        //Now locate the temp dir we are restoring from        if ($status) {            $temp_path = $CFG->dataroot."/temp/backup/".$restore->backup_unique_code.                         "/moddata/podcast/media/".$oldid_podcast;            //Check it exists            if (is_dir($temp_path)) {                $todo = true;            }        }		        if ($status and $todo) {            //And now, copy temp_path to post_podcast_path            $status = backup_copy_file($temp_path, $podcast_path);        }						// XML    	// in CFG->dataroot        $dest_dir = $CFG->dirroot."/mod/podcast/publication/".$restore->course_id;        $status = check_dir_exists($dest_dir,true);		        //Now, locate podcast directory        if ($status) {            $podcast_path = $dest_dir;            //Check it exists and create it            $status = check_dir_exists($podcast_path,true);        }        //Now locate the temp dir we are restoring from        if ($status) {            $temp_path = $CFG->dataroot."/temp/backup/".$restore->backup_unique_code.                         "/moddata/podcast/publication/";            //Check it exists            if (is_dir($temp_path)) {                $todo = true;            }        }		        if ($status and $todo) {            //And now, copy temp_path to post_podcast_path            $status = backup_copy_file($temp_path."rss".$oldid_podcast.".xml", $podcast_path."/rss".$newid_podcast.".xml");        }						        return $status;    }?>