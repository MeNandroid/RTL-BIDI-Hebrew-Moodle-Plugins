<?php// Poscast - backuplib.php, 24/02/2007/** * Fonction de sauvegarde de l'activit� Podcast. */	function podcast_backup_mods($bf,$preferences) {        global $CFG;        $status = true;        //Iterate over podcast table        $podcasts = get_records ("podcast","course",$preferences->backup_course,"id");        if ($podcasts) {            foreach ($podcasts as $podcast) {                if (backup_mod_selected($preferences,'podcast',$podcast->id)) {                    $status = podcast_backup_one_mod($bf,$preferences,$podcast);                }            }        }        return $status;    }    function podcast_backup_one_mod($bf,$preferences,$podcast) {        global $CFG;        if (is_numeric($podcast)) {            $podcast = get_record('podcast','id',$podcast);        }        $status = true;        //Start mod        fwrite ($bf,start_tag("MOD",7,true));        //Print podcast data        fwrite ($bf,full_tag("ID",8,false,$podcast->id));        fwrite ($bf,full_tag("MODTYPE",8,false,"podcast"));        fwrite ($bf,full_tag("USERID",8,false,$podcast->userid));        fwrite ($bf,full_tag("NAME",8,false,$podcast->name));        fwrite ($bf,full_tag("AUTHOR",8,false,$podcast->author));        fwrite ($bf,full_tag("INTRO",8,false,$podcast->intro));        fwrite ($bf,full_tag("OWNER",8,false,$podcast->owner));        fwrite ($bf,full_tag("OWNER_EMAIL",8,false,$podcast->owner_email));        fwrite ($bf,full_tag("COPYRIGHT",8,false,$podcast->copyright));        fwrite ($bf,full_tag("LANG",8,false,$podcast->lang));        fwrite ($bf,full_tag("PUBDATE",8,false,$podcast->pubdate));        fwrite ($bf,full_tag("IMAGE_URL",8,false,$podcast->image_url));        fwrite ($bf,full_tag("IMAGE_IMG",8,false,$podcast->image_img));        fwrite ($bf,full_tag("CATEGORY",8,false,$podcast->category));        fwrite ($bf,full_tag("TIMEMODIFIED",8,false,$podcast->timemodified));        //if we've selected to backup users info, then execute backup_podcast_items        if (backup_userdata_selected($preferences,'podcast',$podcast->id)) {            $status = backup_podcast_items($bf,$preferences,$podcast->id);        }        //End mod        $status =fwrite ($bf,end_tag("MOD",7,true));        return $status;    }    //Backup podcast_items contents (executed from podcast_backup_mods)    function backup_podcast_items ($bf,$preferences,$podcast) {        global $CFG;        $status = true;        $podcast_items = get_records("podcast_structure","id_podcast",$podcast,"id");        //If there is items        if ($podcast_items) {            //Write start tag            $status =fwrite ($bf,start_tag("ITEMS",7,true));            //Iterate over each item            foreach ($podcast_items as $item) {                //Start item                $status = fwrite ($bf,start_tag("ITEM",8,true));                //Print item contents                fwrite ($bf,full_tag("ID",9,false,$item->id));                fwrite ($bf,full_tag("ID_PODCAST",9,false,$item->id_podcast));                fwrite ($bf,full_tag("TITLE",9,false,$item->title));                fwrite ($bf,full_tag("LIEN",9,false,$item->lien));                fwrite ($bf,full_tag("INTRO",9,false,$item->intro));                fwrite ($bf,full_tag("PUBDATE",9,false,$item->pubdate));                fwrite ($bf,full_tag("DATE_HTML",9,false,$item->date_html));                fwrite ($bf,full_tag("DURATION",9,false,$item->duration));                fwrite ($bf,full_tag("LENGTH",9,false,$item->length));                //End submission                $status = fwrite ($bf,end_tag("ITEM",8,true));            }            //Write end tag            $status =fwrite ($bf,end_tag("ITEMS",7,true));        }		// Backup of files	 	if ($status) {			// backup files for this item.      		$status = backup_podcast_files_instance($bf,$preferences);        }        return $status;    }    //Return an array of info (name,value)    function podcast_check_backup_mods($course,$user_data=false,$backup_unique_code,$instances=null) {        if (!empty($instances) && is_array($instances) && count($instances)) {            $info = array();            foreach ($instances as $id => $instance) {                $info += podcast_check_backup_mods_instances($instance,$backup_unique_code);            }            return $info;        }        //First the course data        $info[0][0] = get_string("modulenameplural","podcast");        if ($ids = podcast_ids ($course)) {            $info[0][1] = count($ids);        } else {            $info[0][1] = 0;        }        //Now, if requested, the user_data        if ($user_data) {            $info[1][0] = get_string("items","podcast");            if ($ids = podcast_item_ids_by_course ($course)) {                $info[1][1] = count($ids);            } else {                $info[1][1] = 0;            }        }        return $info;    }    //Return an array of info (name,value)    function podcast_check_backup_mods_instances($instance,$backup_unique_code) {        //First the course data        $info[$instance->id.'0'][0] = '<b>'.$instance->name.'</b>';        $info[$instance->id.'0'][1] = '';        //Now, if requested, the user_data        if (!empty($instance->userdata)) {            $info[$instance->id.'1'][0] = get_string("items","podcast");            if ($ids = podcast_item_ids_by_instance ($instance->id)) {                $info[$instance->id.'1'][1] = count($ids);            } else {                $info[$instance->id.'1'][1] = 0;            }        }        return $info;    }    //Return a content encoded to support interactivities linking. Every module    //should have its own. They are called automatically from the backup procedure.    function podcast_encode_content_links ($content,$preferences) {        global $CFG;        $base = preg_quote($CFG->wwwroot,"/");        //Link to the list of podcasts        $buscar="/(".$base."\/mod\/podcast\/index.php\?id\=)([0-9]+)/";        $result= preg_replace($buscar,'$@PODCASTINDEX*$2@$',$content);        //Link to podcast view by moduleid        $buscar="/(".$base."\/mod\/podcast\/view.php\?id\=)([0-9]+)/";        $result= preg_replace($buscar,'$@PODCASTVIEWBYID*$2@$',$result);        return $result;    }    // INTERNAL FUNCTIONS. BASED IN THE MOD STRUCTURE    //Returns an array of podcasts id    function podcast_ids ($course) {        global $CFG;        return get_records_sql ("SELECT p.id, p.course                                 FROM {$CFG->prefix}podcast p                                 WHERE p.course = $course");    }    //Returns an array of assignment_submissions id    function podcast_item_ids_by_course ($course) {        global $CFG;        return get_records_sql ("SELECT s.id , s.id_podcast                                 FROM {$CFG->prefix}podcast_structure s,                                      {$CFG->prefix}podcast p                                 WHERE p.course = $course AND                                       s.id_podcast = p.id");    }    //Returns an array of podcast id    function podcast_item_ids_by_instance ($instanceid) {        global $CFG;        return get_records_sql ("SELECT s.id , s.id_podcast                                 FROM {$CFG->prefix}podcast_structure s                                 WHERE s.id_podcast = $instanceid");    }	//Backup forum files because we've selected to backup user info    //and files are user info's level    function backup_podcast_files($bf,$preferences) {        global $CFG;        $status = true;        //First we check to moddata exists and create it as necessary        //in temp/backup/$backup_code  dir        $status = check_and_create_moddata_dir($preferences->backup_unique_code);        //Now copy the podcast dir        if ($status) {			// MEDIA            if (is_dir($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course)) {                $handle = opendir($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course);				while (false!==($item = readdir($handle))) {                    if ($item != '.' && $item != '..' && is_dir($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course."/".$item)                        && array_key_exists($item,$preferences->mods['podcast']->instances)                        && !empty($preferences->mods['podcast']->instances[$item]->backup)) {                        $status = backup_copy_file($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course."/".$item,                                                   $CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/media/",$item);                    }                }            }			// XML			if (is_dir($CFG->dirroot."/mod/podcast/publication/".$preferences->backup_course)) {                if (is_dir($CFG->dirroot."/mod/podcast/publication/".$preferences->backup_course)) {                	$status = backup_copy_file($CFG->dirroot."/mod/podcast/publication/".$preferences->backup_course, $CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/publication/");				}            }        }        return $status;    }    //Backup podcast files because we've selected to backup user info    //and files are user info's level    function backup_podcast_files_instance($bf,$preferences,$instanceid) {        global $CFG;        $status = true;        // MEDIA        // in temp/backup/$backup_code  dir        $status = check_and_create_moddata_dir($preferences->backup_unique_code);        $status = check_dir_exists($CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/",true);        if ($status) {            // Copie des fichiers multim�dia            if (is_dir($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course."/".$instanceid)) {                $status = backup_copy_file($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course."/".$instanceid,                                           $CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/media/".$instanceid);            }        }		// XML        // in temp/backup/$backup_code  dir        $status = check_and_create_moddata_dir($preferences->backup_unique_code);        $status = check_dir_exists($CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/",true);        if ($status) {			// Copie des fichiers rss            if (is_dir($CFG->dirroot."/mod/podcast/media/".$preferences->backup_course."/".$instanceid)) {                $status = backup_copy_file($CFG->dirroot."/mod/podcast/publication/".$preferences->backup_course,                                           $CFG->dataroot."/temp/backup/".$preferences->backup_unique_code."/moddata/podcast/publication/");            }        }        return $status;    }?>